import lingo/pegcode/driver;
import sys/system;
import algorithms;
import ds/tree;
import string;

Success : ();

AssignOper : (varName : string, expr : Expr, labels : [int]);
TestOper : (cond : BoolExpr, ifLabels : [int], elseLabels : [int]);
PrintOper : (expr : Expr, labels : [int]);

Operation ::= AssignOper, TestOper, PrintOper;

Operator : (label : int, oper : Operation);

Redeclaration : (varName : string);
InvalidType : (e : Expr);
AssignToUndeclaredVar : (varName : string);
AssignTypeMismatch : (a : Assign);

AnalyzeRes ::= Success, Redeclaration, InvalidType, AssignToUndeclaredVar, AssignTypeMismatch;

Int : ();
String : ();
Bool : ();
Real : ();
NoType : ();
AnyType : ();

Array : (base : ExprType);

VarType ::= Int, String, Bool, Real, Array;
ExprType ::= VarType, NoType, AnyType;

VarDecl : (name : string, type : VarType);
VDlist : (elements : [VarDecl]);
Var : (name : string);

VMProg : (varDeclList : VDlist, operators : [Operator]);

IntConst : (value: int);
StringConst : (value : string);
BoolConst : (value : bool);
RealConst : (value : double);
ArrayConst : (values : Tree<int, Const>); 
NonBoolConst ::= IntConst, StringConst, RealConst, ArrayConst;

Const ::= NonBoolConst, BoolConst;

AAddOp : ();
ASubOp : ();
AMulOp : ();
ADivOp : ();

ArithmBinaryOp ::= AAddOp, ASubOp, AMulOp, ADivOp;

ABin : (l : Expr, r : Expr, op : ArithmBinaryOp);
ANeg : (e : Expr);

AExpr ::= ABin, ANeg;

Equal : ();
Less : ();

CompType ::= Equal, Less;

Comp : (l : Expr, r : Expr, compType : CompType);

Not : (e : BoolExpr);
Or : (l : BoolExpr, r : BoolExpr);

BoolExpr ::= Comp, Not, Or, BoolConst;

ArrUpdateOp : (ind : Expr, val : Expr);
ArrApplyOp: (ind : Expr);
ArrConcatOp : (arr2 : Expr);
ArrLengthOp : ();
ArrOpType ::= ArrUpdateOp, ArrApplyOp, ArrConcatOp, ArrLengthOp;
ArrOp : (arr : Expr, opType : ArrOpType);

Expr ::= Var, Const, AExpr, ArrOp, BoolExpr;

Assign : (varName : string, expr : Expr);
BodiesSeq : (bodies : [Body]);
Test : (be : BoolExpr);
Print : (e : Expr);
UDChoice : (bodies : [Body]);
UDIterate : (body : Body);

Body ::= Assign, BodiesSeq, Test, UDChoice, UDIterate, Print;

NemoProg : (vdlist : VDlist, body : Body);

doRange(len : int, acc : [int], index : int) -> [int] {
    if (index == len) {
        acc;
    } else {
        doRange(len, arrayPush(acc, index), index + 1);
    }
}

range(maxIndex : int) -> [int] {
    doRange(maxIndex + 1, [], 0);
}

constTree2s(t : Tree<int, Const>) -> string {
    switch (popmax(t)) {
        EmptyPopResult() : "[]";
        PopResult(k, v, t1) : {
            maxIndex = k;
            r = range(maxIndex);
            l = foldi(range(maxIndex), "", \i, acc, e -> {
                curConst = lookupTree(t, e);
                curConstRepr = eitherMap(curConst, const2s, "__");
                tmp = acc + curConstRepr;
                if (i == maxIndex) {
                    tmp;
                } else {
                    tmp + ", ";
                }
            });
            "[" + l + "]";
        };
    };
}

exprType2s(t : ExprType) -> string {
    switch (t) {
        Int() : "INT";
        String() : "STRING";
        Bool() : "BOOL";
        Real() : "REAL";
        Array(base) : "["+exprType2s(base)+"]";
        NoType() : "#no_type#";
        AnyType() : "#any_type#";
    }
}

varDecl2s(vd : VarDecl) -> string {
    "VAR " + vd.name + " : " + exprType2s(vd.type) + ";";
}

VDlist2Str(vdlist : VDlist) -> string {
    fold(vdlist.elements, "", \s, d -> {s + varDecl2s(d) + "\n";});
}

boolConst2s(b : BoolConst) -> string {
    b2s(b.value);
}

const2s(c : Const) -> string {
    switch (c) {
        IntConst(val) : i2s(val);
        StringConst(val) : "\""+val +"\"";
        BoolConst(val) : boolConst2s(c);
        RealConst(val) : d2s(val);
        ArrayConst(val) : constTree2s(val);
    }
}

AExpr2s(a : AExpr) -> string {
    withoutBrackets = switch (a) {
        ABin(l, r, op) : {
            ls = expr2s(l);
            rs = expr2s(r);

            switch (op) {
                AAddOp() : ls + " + " + rs;
                ASubOp() : ls + " - " + rs;
                AMulOp() : ls + " * " + rs;
                ADivOp() : ls + " / " + rs;
            };
        }

        ANeg(e) : "-" + expr2s(e);
    }
    "(" + withoutBrackets + ")";
}

arrayOp2s(a : ArrOp) -> string {
    arr = a.arr;
    arrRepr = expr2s(arr);

    switch (a.opType) {
        ArrUpdateOp(index, val) : "UPD()" + arrRepr + ", " + expr2s(index) + ", " + expr2s(val) + ")";
        ArrApplyOp(index) : "APP(" + arrRepr + ", " + expr2s(index) + ")";
        ArrConcatOp(arr2) : "CONCAT(" + arrRepr + ", " + expr2s(arr2) + ")";
        ArrLengthOp() : "LENGTH(" + arrRepr + ")"; 
    }
}

compType2s(ct : CompType) -> string {
    switch (ct) {
        Less() : " < ";
        Equal() : " = ";
    }
}

boolExpr2s(b : BoolExpr) -> string {
    switch (b) {
        Comp(l, r, ct) : expr2s(l) + compType2s(ct) + expr2s(r);
        Not(e) : "NOT(" + boolExpr2s(e) + ")";
        Or(l, r) : "(" + boolExpr2s(l) + ") OR (" + boolExpr2s(r) + ")";
        BoolConst(val) : boolConst2s(b);
    }
}

expr2s(e : Expr) -> string {
    switch (e) {
        NonBoolConst() : const2s(e);
        Var(v) : v;
        AExpr() : AExpr2s(e);
        ArrOp(arr, opType) : arrayOp2s(e)
        BoolExpr() : boolExpr2s(e);
    }
}

buildVarDecls(a : [flow]) {
    VDlist(a[0]);
}

buildTrueConst(a : [flow]) {
    BoolConst(true);
}

buildFalseConst(a : [flow]) {
    BoolConst(false);
}

buildArrayConst(a : [flow]) {
    if (length(a) == 0) {
        ArrayConst(makeTree());
    } else {
        vals = concat(a[0], a[1]);
        treeOfVals = foldi(vals, makeTree(), \i, acc, v -> setTree(acc, i, v));
        ArrayConst(treeOfVals);
    }
}

buildASub(a : [flow]) {
    fold(a[1], a[0], \acc, e -> ABin(acc, e, ASubOp()));
}

buildADiv(a : [flow]) {
    fold(a[1], a[0], \acc, e -> ABin(acc, e, ADivOp()));
}

buildLess1(e1: Expr, e2: Expr) {
    Comp(e1, e2, Less());
}

buildEqual1(e1: Expr, e2: Expr) {
    Comp(e1, e2, Equal());
}

buildLess(a : [flow]) {
    buildLess1(a[0], a[1]);
}

buildEqual(a : [flow]) {
    buildEqual1(a[0], a[1]);
}

buildLessOrEqual(a : [flow]) {
    t1 = a[0];
    t2 = a[1];
    Or(buildEqual1(t1, t2), buildLess1(t1, t2));
}

buildGreater(a : [flow]) {
    buildLess1(a[1], a[0]);
}

buildGreaterOrEqual(a : [flow]) {
    t1 = a[0];
    t2 = a[1];
    Or(buildEqual1(t1, t2), buildLess1(t2, t1));
}

buildNotEqual(a : [flow]) {
    Not(buildEqual1(a[0], a[1]));
}

buildAnd(a : [flow]) {
    Not(Or(Not(a[0]), Not(a[1])));
}

buildBodiesSeq(a : [flow]) {
    BodiesSeq(a[0]);
}

buildUDChoice(a : [flow]) {
    UDChoice(concat(a[0], a[1]));
}

specialPegAction = {
    actions : [Pair<string, ([flow]) -> flow>] = [
        Pair("buildVarDecls", buildVarDecls),
        Pair("buildTrueConst", buildTrueConst),
        Pair("buildFalseConst", buildFalseConst),
        Pair("buildArrayConst", buildArrayConst),
        Pair("buildASub", buildASub),
        Pair("buildADiv", buildADiv),
        Pair("buildLess", buildLess),
        Pair("buildEqual", buildEqual),
        Pair("buildLessOrEqual", buildLessOrEqual),
        Pair("buildGreater", buildGreater),
        Pair("buildGreaterOrEqual", buildGreaterOrEqual),
        Pair("buildNotEqual", buildNotEqual),
        Pair("buildAnd", buildAnd),
        Pair("buildBodiesSeq", buildBodiesSeq),
        Pair("buildUDChoice", buildUDChoice),
    ];

    SemanticActions(fold(actions, defaultPegActions.t, \acc, p -> {setTree(acc, p.first, p.second);}));
}

parse(progString : string) -> flow {
    grammar = compilePegGrammar("#include nemo_grammar.lingo");
    parsic(grammar, progString, specialPegAction);
}

analyzeRes2s(res : AnalyzeRes) -> string {
    switch (res) {
        Success() : "Success";
        InvalidType(e) : "InvalidType: " + expr2s(e);
        Redeclaration(e) : "Redeclaration: " + e;
        AssignToUndeclaredVar(e) : "AssignToUndeclaredVar: " + e;
        AssignTypeMismatch(e) : "AssignTypeMismatch: " + expr2s(e.expr);
    }
}

getDeclVar(prog : NemoProg) -> Tree<string, [VarDecl]> {
    fold(prog.vdlist.elements, makeTree(), \acc, e -> {
        treePushToArrayValue(acc, e.name, e);
    });
}

analyzeDeclVars(declVars : Tree<string, [VarDecl]>) -> AnalyzeRes {
    foldTree(declVars, Success(), \varName, decls, acc -> {
        if (acc != Success()) {
            acc;
        } else {
            if (length(decls) > 1) {
                Redeclaration(varName);
            } else {
                Success();
            }
        }
    });
}

areArrWithSimType1(a1 : ExprType, a2 : ExprType) -> bool {
    switch (a1) {
        Array(b1) : {
            switch (a2) {
                Array(b2) : b1 == AnyType() || b2 == AnyType() || b1 == b2 || areArrWithSimType1(b1, b2);
                default : false;
            }
        }
        default : false;
    }
}

areArrWithSimType(ts : [ExprType]) -> bool {
    foldi(ts, true, \i, acc, e -> {
        if (i == length(ts) - 1) {
            acc;
        } else {
            acc && areArrWithSimType1(ts[i], ts[i + 1]);
        }
    })
}

chooseMostSpecArrType1(a1 : ExprType, a2 : ExprType) -> ExprType {
    switch (a1) {
        Array(b1) : {
            if (b1 != AnyType()) {
                a1;
            } else {
                switch (a2) {
                    Array(b2) : {
                        a2
                    }
                    default : NoType();
                }
            }
        }
        default : NoType();
    }
}

chooseMostSpecArrType(ts : [ExprType]) -> ExprType {
    fold(ts, Array(AnyType()), \acc, e -> chooseMostSpecArrType1(acc, e));
}

isTypeNumeric(t : ExprType) -> bool {
    t == Int() || t == Real();
}

isArrayType(t : ExprType) -> bool {
    switch (t) {
        Array(base) : true;
        default : false;
    }
}

isBoolExprCorrect(b : BoolExpr, varTypes : Tree<string, ExprType>) -> bool {
    switch (b) {
        Comp(l, r, ct) : {
            lType = calcTypeOfExpr(l, varTypes);
            rType = calcTypeOfExpr(r, varTypes);

            if (lType == NoType() || rType == NoType() || lType != rType) {
                false;
            } else {
                switch (ct) {
                    Less() : isTypeNumeric(lType);
                    Equal() : true;
                }
            }
        }
        Not(e) : isBoolExprCorrect(e, varTypes);
        Or(l, r) : isBoolExprCorrect(l, varTypes) && isBoolExprCorrect(r, varTypes);
        BoolConst(val) : true;
    }
}

analyzeType(e : Expr, et : ExprType) -> AnalyzeRes {
    if (et == NoType()) {
        InvalidType(e);
    } else {
        Success();
    }
}

analyzeExpr(e : Expr, varTypes : Tree<string, ExprType>) -> AnalyzeRes {
    analyzeType(e, calcTypeOfExpr(e, varTypes));
}

analyzeAssign(a : Assign, varTypes : Tree<string, ExprType>) -> AnalyzeRes {
    varName = a.varName;
    expr = a.expr;
    
    varType = lookupTreeDef(varTypes, varName, NoType());

    if (varType == NoType()) {
        AssignToUndeclaredVar(varName);
    } else {
        exprType = calcTypeOfExpr(expr, varTypes);

        if (exprType == NoType()) {
            analyzeType(expr, exprType);
        } else {
            if (exprType == varType || areArrWithSimType1(exprType, varType)) {
                Success();
            } else {
                AssignTypeMismatch(a);
            }
        }
    }
}

analyzeTest(t : Test, varTypes : Tree<string, ExprType>) -> AnalyzeRes {
    analyzeExpr(t.be, varTypes);
}

analyzePrint(p : Print, varTypes : Tree<string, ExprType>) -> AnalyzeRes {
    analyzeExpr(p.e, varTypes);
}

analyzeBodies(bod : [Body], varTypes : Tree<string, ExprType>) -> AnalyzeRes {
    fold(bod, Success(), \acc, b -> {
        if (acc != Success()) {
            acc;
        } else {
            res = analyzeBody(b, varTypes);
            if (res != Success()) {
                res;
            } else {
                Success();
            }
        }
    });
}

analyzeBody(b : Body, varTypes : Tree<string, ExprType>) -> AnalyzeRes {
    switch (b) {
        Assign(varName, expr) : analyzeAssign(b, varTypes);
        Test(boolExpr) : analyzeTest(b, varTypes);
        Print(expr) : analyzePrint(b, varTypes);
        BodiesSeq(bodies) : analyzeBodies(bodies, varTypes);
        UDChoice(bodies) : analyzeBodies(bodies, varTypes);
        UDIterate(b1) : analyzeBody(b1, varTypes);
    }
}

analyze(prog : NemoProg) -> AnalyzeRes {
    declVars = getDeclVar(prog);
    res = analyzeDeclVars(declVars);

    if (res != Success()) {
        res;
    } else {
        varTypes = foldTree(declVars, makeTree(), \varName, decls, acc -> setTree(acc, varName, decls[0].type));
        analyzeBody(prog.body, varTypes);
    }
}

calcTypeOfConst(c : Const) -> ExprType {
    switch (c) {
        IntConst(val) : Int();
        StringConst(val) : String();
        BoolConst(val) : Bool();
        RealConst(val) : Real();
        ArrayConst(val) : {
            keyValPairs = tree2pairs(val);
            vals = map(keyValPairs, \pair -> pair.second);

            if (length(vals) == 0) {
                Array(AnyType());
            } else {
                elementsTypes = map(vals, \v -> calcTypeOfConst(v));

                if (contains(elementsTypes, NoType())) {
                    NoType();
                } else {
                    if (areArrWithSimType(elementsTypes)) {
                        Array(chooseMostSpecArrType(elementsTypes));
                    } else if (countA(elementsTypes, \e -> e == elementsTypes[0]) == length(elementsTypes)) {
                        Array(elementsTypes[0]);
                    } else {
                        NoType();
                    }
                }
            }
        }
    }
}

calcTypeOfAExpr(a : AExpr, varTypes : Tree<string, ExprType>) -> ExprType {
    switch (a) {
        ABin(l, r, op) : {
            lType = calcTypeOfExpr(l, varTypes);
            rType = calcTypeOfExpr(r, varTypes);
            if (lType == NoType() || rType == NoType() || lType != rType || !isTypeNumeric(lType)) {
                NoType();
            } else {
                lType;
            }
        }
        ANeg(e) : {
            eType = calcTypeOfExpr(e, varTypes);
            if (!isTypeNumeric(eType)) {
                NoType();
            } else {
                eType;
            }
        }
    }
}

calcTypeOfArrayOp(op : ArrOp, varTypes : Tree<string, ExprType>) -> ExprType {
    firOperand = op.arr;
    firOperandType = calcTypeOfExpr(firOperand, varTypes);

    switch (firOperandType) {
        Array(base) : {
            switch (op.opType) {
                ArrUpdateOp(index, val) : {
                    indexType = calcTypeOfExpr(index, varTypes);
                    valType = calcTypeOfExpr(val, varTypes);

                    if (indexType != Int()) {
                        NoType();                   
                    } else if (base == AnyType() || base == valType) {
                        Array(base);
                    } else {
                        NoType();
                    }
                }
                ArrApplyOp(index) : {
                    if (calcTypeOfExpr(index, varTypes) != Int()) {
                        NoType();
                    } else {
                        base;
                    }
                }
                ArrConcatOp(arr2) : {
                    arr2Type = calcTypeOfExpr(arr2, varTypes);
                    if (!areArrWithSimType1(firOperandType, arr2Type)) {
                        NoType();
                    } else {
                        chooseMostSpecArrType1(firOperandType, arr2Type);
                    }
                }
                ArrLengthOp() : Int();
            }
        }
        default : NoType();
    }
}

calcTypeOfExpr(e : Expr, varTypes : Tree<string, ExprType>) -> ExprType {
    switch (e) {
        NonBoolConst() : calcTypeOfConst(e);
        Var(v) : lookupTreeDef(varTypes, v, NoType());
        AExpr() : calcTypeOfAExpr(e, varTypes);
        ArrOp(arr, opType) : calcTypeOfArrayOp(e, varTypes);
        BoolExpr() : {
            if (isBoolExprCorrect(e, varTypes)) {
                Bool();
            } else {
                NoType();
            }
        };
    }
}

findMaxLabelOfOperation(oper : Operation) -> int {
    maxOfArr = \a -> fold(a, 0, \acc, e -> max(acc, e));

    switch (oper) {
        AssignOper(varName, expr, labels) : maxOfArr(labels);
        TestOper(cond, ifLabels, elseLabels) : max(maxOfArr(ifLabels), maxOfArr(elseLabels));
        PrintOper(expr, labels) : maxOfArr(labels);
    }
}

findMaxLabelOfOperator(op : Operator) -> int {
    max(op.label, findMaxLabelOfOperation(op.oper));
}

findMaxLabelOfOperators(operators : Set<Operator>) -> int {
    foldSet(operators, 0, \acc, op -> max(acc, findMaxLabelOfOperator(op)));
}

increaseLabel(label : int, delta : int) -> int {
    label + delta;
}

replaceLabel(label : int, newLabel : int, oldLabel : int) -> int {
    if (label == oldLabel) {
        newLabel;
    } else {
        label;
    }
}

increaseLabelsOfOperation(oper : Operation, delta : int) -> Operation {
    incLabels = \lab -> map(lab, \l -> increaseLabel(l, delta));

    switch (oper) {
        AssignOper(varName, expr, labels) : AssignOper(varName, expr, incLabels(labels));
        TestOper(cond, ifLabels, elseLabels) : TestOper(cond, incLabels(ifLabels), incLabels(elseLabels));
        PrintOper(expr, labels) : PrintOper(expr, incLabels(labels));
    }
}

replaceLabelsOfOperation(oper : Operation, newLabel : int, oldLabel : int) -> Operation {
    repLabels = \lab -> map(lab, \l -> replaceLabel(l, newLabel, oldLabel));

    switch (oper) {
        AssignOper(varName, expr, labels) : AssignOper(varName, expr, repLabels(labels));
        TestOper(cond, ifLabels, elseLabels) : TestOper(cond, repLabels(ifLabels), repLabels(elseLabels));
        PrintOper(expr, labels) : PrintOper(expr, repLabels(labels));
    }
}

increaseLabelsOfOperators(operators : Set<Operator>, delta : int) -> Set<Operator> {
    incLabels = \op -> Operator(increaseLabel(op.label, delta), increaseLabelsOfOperation(op.oper, delta));
    mapSet(operators, incLabels);
}

incrementLabelsOfOperators(operators : Set<Operator>) -> Set<Operator> {
    increaseLabelsOfOperators(operators, 1);
}

replaceLabelsOfOperators(operators : Set<Operator>, newLabel : int, oldLabel : int) -> Set<Operator> {
    repLabels = \op -> Operator(replaceLabel(op.label, newLabel, oldLabel), replaceLabelsOfOperation(op.oper, newLabel, oldLabel));
    mapSet(operators, repLabels);
}

transVDlist(vdlist : VDlist) -> string {
    VDlist2Str(vdlist);
}

bodies2Operators(bodies : [Body], f : (firEl : Body, tailEl : [Body]) -> Set<Operator>) -> Set<Operator> {
    len = length(bodies);

    if (len == 0) {
        makeSet();
    } else if (len == 1) {
        body2Operators(bodies[0]);
    } else {
        f(bodies[0], tail(bodies));
    }
}

body2Operators(body : Body) -> Set<Operator> {
    createBranch = \l -> Operator(0, TestOper(BoolConst(true), [1, l], []));
    createStartOperator = \op -> Operator(0, op);

    switch (body) {
        Assign(varName, expr) : makeSet1(createStartOperator(AssignOper(varName, expr, [1])));
        Test(boolExpr) : makeSet1(createStartOperator(TestOper(boolExpr, [1], [])));
        Print(expr) : makeSet1(createStartOperator(PrintOper(expr, [1])));
        BodiesSeq(bodies) : bodies2Operators(bodies, \firEl, tailEl -> {
            s1 = body2Operators(firEl);
            l1 = findMaxLabelOfOperators(s1);
            s2 = increaseLabelsOfOperators(body2Operators(BodiesSeq(tailEl)), l1);
            mergeSets(s1, s2);
        });
        UDChoice(bodies) : bodies2Operators(bodies, \firEl, tailEl -> {
            s1 = incrementLabelsOfOperators(body2Operators(bodies[0]));
            l1 = findMaxLabelOfOperators(s1);
            s2 = increaseLabelsOfOperators(body2Operators(UDChoice(tail(bodies))), l1);
            l2 = findMaxLabelOfOperators(s2);
            s3 = makeSet1(createBranch(l1));
            mergeSetsA([replaceLabelsOfOperators(s1, l2, l1), s2, s3]);
        });
        UDIterate(b1) : {
            s1 = incrementLabelsOfOperators(body2Operators(b1));
            l1 = findMaxLabelOfOperators(s1);
            s2 = makeSet1(createBranch(l1));
            mergeSets(replaceLabelsOfOperators(s1, 0, l1), s2);
        };
    }
}

sortOperators(operators : [Operator]) -> [Operator] {
    mergeSort(operators, \op1, op2 -> {l1 = op1.label; l2 = op2.label; l1-l2;});
}

labels2s(labels : [int]) -> string {
    labelsRepr = foldi(sort(labels), "", \i, acc, e -> {
        tmp = acc + i2s(e);
        if (i == length(labels) - 1) {
            tmp;
        } else {
            tmp + ", ";
        }
    });
    "{" + labelsRepr + "}";
}

operation2s(oper : Operation) -> string {
    switch (oper) {
        AssignOper(varName, expr, labels) : varName + " := " + expr2s(expr) + "goto " + labels2s(labels);
        TestOper(cond, ifLabels, elseLabels) : "if (" + expr2s(cond) + ") then " + labels2s(ifLabels) + " else " + labels2s(elseLabels);
        PrintOper(expr, labels) : "print " + expr2s(expr) + " goto " + labels2s(labels);
    }
}

operator2s(op : Operator) -> string {
    i2s(op.label) + ": " + operation2s(op.oper) + ";";
}

transBody(body : Body) -> string {
    set = body2Operators(body);
    arr = set2array(set);
    fold(sortOperators(arr), "", \acc, oper -> acc + operator2s(oper) + "\n");
}

translate(prog : NemoProg) -> string {
    transVDlist(prog.vdlist) + "\n" + transBody(prog.body);
}

main() {
    prog = parse("#include program.nemo");
    res = analyze(prog);

    if (res != Success()) {
        println(analyzeRes2s(res));
    } else {
        if (!setFileContent("./program.out", translate(prog))) {
            println("Cannot write to file");
        }
    }

    quit(0);
}